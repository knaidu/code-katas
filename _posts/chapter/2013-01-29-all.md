---
layout: post
---

## Copyright and License

Ruby Book on Algorithms: An Introduction to Data Structures and Algorithms. Copyright © 2013 by Jason Kim. All source code in Ruby Book on Algorithms is available under the MIT License.

### What does this mean?

#### Code

Feel free to share the code in this book. You can build on it.

#### Book

Feel free to share the book link with anyone. But don't reproduce copies of the book in any other way. Please do not solicitate payment for this book or the book link.

### Got a question?

For any questions, concerns, bugs in codes, typos, etc, please email [jason.kim@live.ca](jason.kim@live.ca).

{% include table-of-contents.html %}

## 1. Overview

There were some important choices that had to be made in writing the book. This is a chapter dedicated to justifying some of these decisions.

### Why Ruby?

There are hundreds of programming languages out there. So why should you program in Ruby?

Programmers have different preferences and styles of programming. Depending on programmers' values and experiences, programmers can aptly give reasons why they think people should choose certain programming language. Although programmers may like different languages for different reasons, their opinions are usually correct in identifying why certain programming languages are great for certain uses. This is because programming languages have identifiable characteristics programmers can point to and compare with one another. 

I like to program in Ruby because Ruby is *succinct* and highly *practical* language that is *widely used* by many programmers in the industry.

Ruby codes are succint and highly readable. This is an opinion that's commonly shared among non-Ruby programmers as well. Even with minimal programming experience, you'll be able to read and understand elementary Ruby codes. In many ways, this characteristic carries over to more complex Ruby codes too. There are some unusual syntaxes that are unique to Ruby, but once you understand what they do, you'll be able to read and understand complex Ruby code like you'd do with simple Ruby code. Like reading code, writing code feels more straight forward and even enjoyable.

Ruby has powerful programming language features that lets you write functional programs with less code. Just ask thousands of developers using [Ruby on Rails](http://rubyonrails.org/) to build applications serving millions of users everyday. Writing code in Ruby will improve your productivity.

Ruby is a popular language. Its popularity exploded since Ruby on Rails was introduced in 2004. Beginners will have an easier time getting help thanks to large [Ruby community on StackOverflow](http://stackoverflow.com/questions/tagged/ruby). Your coding skills in Ruby will also be useful in finding a career as a developer as well. There are plenty of companies looking for Ruby developers.

### How About C++ and Java?

C++ and Java are popular programming languages of choice for data structures and algorithms courses in university. C++ and Java are fast programming language. By "fast" I mean, if you had a program written in C++ or Java that does same things as a program written in Ruby, the program written in C++ or Java will have more executions per given time.

C++ and Java are also more popular than Ruby. There are more C++ or Java programmers than Ruby programmers. There are more companies looking for C++ or Java programmers as well.

On the other hand, demonstrating high level concepts in data structures and algorithms with Ruby is more suitable as Ruby is packed with higher-order functions like map, block, closures and others. This means several practical benefits for a programmer. Since there are less things to manage by the programmer with powerful higher-order functions in Ruby, the programmer will tend to make less mistakes. The programmer will likely be more productive with higher-order functions because you can express more with less code.

Utilizing such a high level programming such as Ruby comes with the price of nothing being able to present some important concepts in lower level programming languages such as memory management. C++ and Java certainly are not poor choice for university courses.

This book chose Ruby as the programming language of choice because of the emphasis placed on actually implementing all the data structures and algorithms to be presented in the book. You can certainly use C++ or Java to do the same, but it likely will require more time and effort to do so in comparison to Ruby.

### Code vs. Pseudocode

The book encourages implementing various algorithms in the book. Actually coding the algorithms provides different sort of experience than simply reading the book. As the readers code, they will gain different insights in algorithms which the book alone cannot provide.

There are many books that utilize pseudocode to lay out the steps to implement algorithms. Pseudocode has an advantage over code in providing the reader a clear conceptual path towards implementing algorithm in various programming languages.

With that said, the undeniable benifit of being able to run the code readily trumped using pseudocode in the book. And as you become more comfortable with Ruby, reading Ruby code will become much easier than reading pseudocode.

### Setting Up Ruby Development Environment

#### Mac OS X

Ruby versions 1.8 and 1.9 are currently in wide use. We will use Ruby version 1.9.3 specifically and we will use [RVM](https://rvm.io/) to manage multiple Ruby versions.

##### Step 1: Check Ruby Version

Open Terminal and run this command to check the current version of Ruby install on the computer.

`ruby -v`

The Ruby version is most likely 1.8.7. OS X comes preinstalled with Ruby 1.8.7. If it is 1.9.3 by any chance, you are off the hook. You can skip the rest of the steps and move onto the next chapter. If the Ruby version is 1.8.7, follow step 2.

##### Step 2: Install Git

Git is code version control system that Linus Torvalds originally authored. Linus Torvalds is the original creator of Linux. Let's check if git is installed on your machine.

`git --version`

If git is installed, you should be returned with the version of git installed on your machine. If not, [go to git website, and download the git installation package for Mac](http://git-scm.com/downloads). Install the installation package.

##### Step 3: Install Xcode

[Xcode](https://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12) provides development environment for Mac OS and iOS. It is prudent to install Xcode because many software packages related to software development on Mac has different parts of Xcode as dependancy. Sooner or later, you will be faced with some installation error for some software package that can easily be fixed with installing Xcode. You can [install Xcode through App Store](https://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12). 

##### Step 4: Install RVM

RVM stands for Ruby Version Manager. There are multiple popular Ruby versions out there and many different Ruby projects use different Ruby versions.

Follow the installation guide provided in the [RVM website](https://rvm.io/rvm/install/) to install Ruby.

#### Ubuntu

##### Step 1: Update Ubuntu

Run `sudo apt-get update` in the terminal, and enter the password.

##### Step 2: Install Git

To install git, we must install its dependencies.

`sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev build-essential`

And we can install git now.

`sudo apt-get install git`

##### Step 3: Install RVM

We need curl to install RVM.

`sudo apt-get insatll curl`

We are ready to install RVM.

`\curl -L https://get.rvm.io | bash -s stable --ruby`

RVM and Ruby installation might take a while. When the installation is finished, you can check that Ruby is installed by running this.

`ruby -v\`

#### Windows

Ruby development on Windows can be done, but it is not ideal. Ubuntu on VirtualBox will provide easier path to development thanks to powerful terminal, ease of app installation and maintenance, and abundance of help on Ubuntu from open source community for Ruby.

##### Step 1: Download and Install VirtualBox

[VirtualBox](https://www.virtualbox.org/) allows a machine to run multiple operating systems simultaneously. With VirtualBox, a machine running Windows will be able to run Ubuntu as well. Go to VirtualBox website and [download and install the version for Windows](https://www.virtualbox.org/wiki/Downloads).

##### Step 2: Download Ubuntu

Ubuntu can be [downloaded for free at their website](http://www.ubuntu.com/download/desktop). Select Ubuntu 12.04 LTS.

##### Step 3: Install Ubuntu on Virtual Machine

Open VirtualBox and select "New". (Ignore the "ubuntu12" OS already installed in the screenshot)

![VirtualBox](/images/1_virtualbox.png)

Select the name of the operating system and select Linux as the type and Ubuntu as the version. Click continue.

![VirtualBox 2](/images/1_virtualbox_2.png)

Memory size of 512 MB is fine. Click continue.

![VirtualBox 3](/images/1_virtualbox_3.png)

Select "Create a virtual hard drive now" and click "Create".

![VirtualBox 4](/images/1_virtualbox_4.png)

Select "VDI" as the hard drive file type and click "Continue".

![VirtualBox 5](/images/1_virtualbox_5.png)

Select "Dynamically allocated" and click "Continue".

![VirtualBox 6](/images/1_virtualbox_6.png)

Review the name and storage size and click "Create".

![VirtualBox 7](/images/1_virtualbox_7.png)

Once you create an instance of virtual machine, start installing Ubuntu on virtual machine.

Once Ubuntu VM is ready, go through the Ruby installation process shown in the previous section.

---

## 2. Introduction to Ruby

This is a very brief introduction to Ruby programming language. While this section is sufficient for following tutorials in the book, it is in no way a complete guide to Ruby. Keep in mind throughout this section that the introduction obmits a large chunk of Ruby. Also some new Ruby syntaxes will be introduced in future sections which are not covered in this section.

### Hello World!

#### Interactive Ruby Shell (IRB)

Interactive Ruby Shell, more commonly known as IRB is a great tool to run concise Ruby scripts. In order to fire up IRB, open your terminal and type `irb`. You should see `1.9.3p194 :001 >` in your terminal. In IRB, type Code 2.1 and press enter.

##### Code 2.1

    "Hello World!"

This should return ` => "Hello World!" `. Boom! There's your first Ruby program.
### Variables

#### Local Variables

These are all valid local variables.

##### Code 2.1

    foobar
    foobar2
    this_is_a_variable
    _this_is_fine_too

Local variables begin with a lowercase letter (a-z) or underscore(_). It can end with either lowercase letter or number (0-9).

Local variables are accessible within the block it was initialized in.

#### Instance Variables

Instance variables belongs to the class itself. It begins with `@`

##### Code 2.2

    @foobar
    @foo_bar

### Built-in Data Types

Ruby has several built-in ways to represent data. Using these basic building blocks to represent data, you can build more complex data structures such as lists and trees later.

#### String

String objects represent text characters by storing sequences of bytes. String objects are instantiated simply using single quotes, `'` or double quotes, `"`.

##### Code

    "string value"
    'this is also a string value'
    
You can also insert a variable into a string, and Ruby compiler will attempt to convert the variable's type to string type. This is done by inserting variable in `#{variable_name}`.

##### Code
    
    x = "Kurt"
    "#{x} Cobain played for Nirvana." # => "Kurt Cobain played for Nirvana."

You can also embed ruby code within `#{}`.

##### Code

    "3*3 is equal to #{3*3}." # => "3*3 is equal to 9."

#### Integer

Ruby represents integer simply by writing a sequence of numbers.

##### Code

    12345     # => 12345
    1         # => 1
    1_000_000 # => 1000000

#### Float

There are several ways to write rational numbers in Ruby.

##### Code
    
    1.0         # => 1.0
    3.14        # => 3.14
    1e12        # => 1000000000000.0 

#### Array

Arrays store a list of values with unique positions, *index*. Arrays are instantiated using square brackets, `[]` and values are separated by commas, `,`. Accessing values in arrays are done by indicating the index of the value you'd like to access.

##### Code

    [1]                            # => [1]
    [1, 2, 3]                      # => [1, 2, 3]
    ["one", "two", "three"]        # => ["one", "two", "three"]
    g = [5, 6, 7]                  # => [5, 6, 7]
    g[0]                           # => 5
    g[2]                           # => 7
    g[3]                           # => nil

Nested arrays are arrays that have other arrays as values.

##### Code

    n = [[3, 4], [5, 6, 7], [8, 9, 10, 11]]
    n[0]                                         # => [3, 4]
    n[2]                                         # => [8, 9, 10, 11]
    n[2][3]                                      # => 11
     
Assigning new values into an array is done by indicating the index of the new value and assigning the new value into the index of the array.

##### Code

    inception = ["level 1", "level 2", "level 3"]
    inception[3] = "limbo"
    inception     # => ["level 1", "level 2", "level 3", "limbo"]

You can overwrite a value in array as well.

##### Code

    g = [5, 6, 7]
    g[0] = "zero"
    g                # => ["zero", 6, 7]
    
You can concatenate two arrays with `+`.

##### Code

    [3, 4] + [5, 6, 7]     # => [3, 4, 5, 6, 7]

#### Hash

Hash is like a dictionary. A dictionary has a respective meaning of a word for every word entry. Similarly, a hash has a *value* for every *key*. Instantiating a hash is doen with squiggly brackets, `{}`.

##### Code

    h = {}
    h["Vancouver"] = "British Columbia"
    h["Toronto"] = "Ontario"
    h["Montreal"] = "Quebec"
    h                # => {"Vancouver"=>"British Columbia", "Toronto"=>"Ontario", "Montreal"=>"Quebec"}
    h["Montreal"]    # => "Quebec"
    
You can assign an array as a value for a key.

##### Code

    starcraft = {}
    starcraft["Terran"] = ["Marine", "Medic", "SCV"]
    starcraft["Zerg"] = ["Zergling", "Hydrarisk", "Drone"]
    starcraft["Protoss"] = ["Zealot", "Dragoon", "Probe"]
    starcraft    # =>  => {"Terran"=>["Marine", "Medic", "SCV"], "Zerg"=>["Zergling", "Hydrarisk", "Drone"], "Protoss"=>["Zealot", "Dragoon", "Probe"]} 

You can assign multiple key-value pairs at the same time.

##### Code

    stars = {"Pablo Honey" => 4, "The Bends" => 4.5, "OK Computer" => 5}

Since Ruby 1.9, you can also use `:` to replace `=>`.

##### Code

    more_stars = {"Kid A": 5, "Amnesiac": 4, "Hail to the Cheif": 4, "In Rainbows": 3}

#### Symbol

Symbols are like string substitutes with some different properties. They often used in Ruby to avoid computationally expensive string comparisons. Symbols start with `:` followed by some symbol name

If you have a code where you are using strings as identifiers for something, consider using symbols instead. For example, if you have two strings, `"male"` and `"female"` as identifier for a person's gender, use `:male` and `:female` to identify a person's gender instead.

You can covert from string to symbol and symbol to string easily using `to_sym` method and `to_s` method.

##### Code

"string_to_symbol".to_sym        # => :string_to_symbol
"string to symbol".to_sym        # => :"string to symbol"
:symbol_to_string.to_s           # => "symbol_to_string" 

#### Boolean

There are only two Boolean values, `true` and `false`. `nil` in Ruby indicates an absence of value. In other programming languages such as JavaScript, `null` is the comparable keyword to `nil` in Ruby. 

#### Range

Range object has a start value, an ending value and a list of values in between. Range starts with a start value, followed by `..` or `...`, and an ending value.

##### Code
    
    (1..5)  # includes the ending value, 5
    (1...5) # does not include the ending value, 5  

You can use range object on alphabets as well, which makes printing alphabets super easy.

##### Code

    ("a".."z").each {|x| print x }    # prints abcdefghijklmnopqrstuvwxyz

You can even do that with alphabets of other languages. Here is a list of Korean vowel alphabets.

##### Code
    
    ("ㅏ".."ㅣ").each {|x| print x}  # prints ㅏㅐㅑㅒㅓㅔㅕㅖㅗㅘㅙㅚㅛㅜㅝㅞㅟㅠㅡㅢㅣ

### Methods

Methods usually define particular behaviours of a class in Ruby. But unlike some other languages such as Java and C#, Ruby method doesn't have to be written for a class. A Ruby method may not belong to any class at all. Return types for a method is not explicitly defined either.

##### Code 2.3

    def square(number)
      number*number
    end

Code 2.3 shows a method named `square` and it takes an argument called `number`. The `square` method multiplies `number` value with another `number` value and returns the multications as the result.

In order to call a method, invoke the name of the method with appropriate argument.

##### Code 2.4
    
    square(4)

Notice that Ruby method does not require explicit `return` keyword. If you are not terminating the method prematurely, use of `return` is discouraged. Code 2.4 shows a method that uses `return` keyword.
##### Code 2.5

    def largest_prime_number_below(number)
      number.downto(2).each do |count_down|
          if is_prime?(count_down)
            return count_down
          end
      end
      false
    end
    
    def is_prime?(count_down)
      2.upto(count_down/2).each do |count_up|
          if count_down%count_up == 0
            return false
          end
      end
      true
    end

`largest_prime_number_below` method takes an argument called `number`, and browse down each number from `number` to 2, which is the smallest prime number. While we go down through each number, `count_down`, we divide the number up with numbers between 2 to half of `count_down` and check for its remainder. If the remainder is 0, we terminate `is_prime?` method by *returning* false. Eitherwise, the block runs up to the half of `count_down` and implicitly returns true. When `is_prime?` for a `count_down` number is true, `largest_prime_number_below` returns the `count_down` number and terminates the method.

Method names are written in lower case letters. Method names may contain numbers and underscore. Method names may also end with an exclamation mark `!` or a question mark `?`.

By convention, a method name ending with `!` denotes that it is a *mutator*. It is a method that changes the argument the method takes. It should be used with caution. A method name ending with `?` denotes that the method returns boolean value of true or false.

#### Iterators

Ruby programmers don't use `while` loops that often. `for` loops are used even less often. This is because Ruby has a wide array of *iterator* methods, you can use on arrays and hash tables. 

Here are some common methods you can apply on collections to get you started.

1. `each` - executes block and returns the list of objects without mutating

    prints 246810 and returns [1, 2, 3, 4, 5]
    
    `[1, 2, 3, 4, 5].each {|x| print x*2}`
    
    prints artists' name and their nationality and returns the hash itself
    
    `{"Justin Bieber" => "Canadian", "Psy" => "Korean", "Nicki Minaj" => "American"}.each {|key, value| puts "#{key}: #{value}" }`

2. `map` - executes block and returns the list of mutated objects

    returns [2, 4, 6, 8, 10]

    `[1, 2, 3, 4, 5].map {|x| x*2}`

3. `select` - returns a list of objects when condition is true
    
    returns [2]

    `[1, 2, 3, 4, 5].select {|x| x==2}`

4. `reject` - returns a list of objects when condition is false

    returns [1, 3, 4, 5]
    
    `[1, 2, 3, 4, 5].reject {|x| x==2}`

5. `uniq` - returns a list without duplicates

    returns [1, 2, 3, 4] 
    
    `[1, 2, 3, 3, 3, 4].uniq`

6. `reverse` - reverse the list

    returns [4, 3, 2, 1]

    `[1, 2, 3, 4].reverse`

7. `compact` - return all non-nil objects

    returns [1, 2, 3, 4]

    `[1, 2, 3, nil, nil, 4].compact`

8. `flatten` - flatten inner arrays

    returns [3, 2, 4, 4] 
    
    `[[3,2], [4,4]].flatten`

9. `partition` - Create two collections. First collection for true, second for false.

    returns  [[4, 5], [1, 6]]

    `[1, 4, 5, 6].partition {|x| x==4 || x==5}`

9. `sort` without argument - Sorts the list

    returns [1, 3, 11, 23, 31, 34]

    `[31, 34, 11, 23, 1, 3].sort`

### Classes and Objects

Ruby is an object orient language. Every value in Ruby is an instance of some class. 

#### Attributes

#### Class Methods and Instance Methods

---

## 3. Linked Lists

A linked list is a linear data structure that is made up of objects connected to one another by pointers. Another linear data structure we looked earlier was a array.

### Differences Between Array and Linked Lists

### Implementing Singly Linked List

#### Linked List Class and Node Class

`SinglyLinkedList` class and `Node` class is used to create instances of the lists and nodes. `attr_accessor` method creates setter and getter method for attributes of `SinglyLinkedList` class and `Node` class. `SinglyLinkedList` class has three attributes, *head*, *tail*, and *count*. `Node` class has two attributes, *data*, and *next*.

##### SinglyLinkedList Class Attributes

- head: a node that points to the starting node of the linked list
- tail: a node that points to the ending node of the linked list
- count: number of nodes in the linked list

##### Node Class Attributes

- data: contains the value of the node
- next: pointer that is used to point to the location of the next node

`initialize` method for `SinglyLinkedList` initializes head, tail and count attributes. Head node and tail node for the linked list are created. Head node points to tail node by setting the next pointer to the tail node. Tail node points to head node by setting the next pointer to the head node, since there are no other nodes in the list.

##### Code

    class SinglyLinkedList
      attr_accessor :head, :tail, :count
  
      def initialize
        @head = Node.new(nil)
        @tail = Node.new(nil)
    
        @head.next = @tail
        @tail.next = @head
        @count = 1
      end
    end

    class Node
      attr_accessor :data, :next
  
      def initialize(data)
        @data = data
      end
    end

#### Instantiation of the Linked List and the Node

We have `initialize` methods ready. We can instiate the list and the node using `new` method.

##### Code

    class SinglyLinkedList
      attr_accessor :head, :tail, :count
      
      def initialize
        @head = Node.new(nil)
        @tail = Node.new(nil)
        
        @head.next = @tail
        @tail.next = @head
        @count = 1
      end
    end
    
    class Node
      attr_accessor :data, :next
      
      def initialize(data)
        @data = data
      end
    end
    
    list = SinglyLinkedList.new
    node = Node.new(1)

If you run the code, nothing interesting appears on the console. Well, let's change that.

##### Code

    list = SinglyLinkedList.new
    node = Node.new(1)

    puts list    # => #<SinglyLinkedList:0x007fa96304cd38>
    puts node    # => #<Node:0x007fa96304cab8>
    puts node.data    # => 1

#### Inserting Nodes into the Linked List

We will create a method that will instantiate a node and insert it into a linked list at the beginning and at the end. 

##### Code

    class SinglyLinkedList
      ...
  
      def insert_front(data)
        @node = Node.new(data)
        @node.next = @head.next
        @head.next = @node
        if @count < 1
          @tail.next = @node
        end
        @count += 1
      end
  
      def insert_back(data)
        @node = Node.new(data)
        @node.next = @tail
        @tail.next.next = @node
        @tail.next = @node
        @count += 1
      end
    end

##### `insert_front` method

`insert_front` method takes `data` as an argument and creates a node with that `data`, which is inserted at the beginning of the linked list.

1. Instantiate a new node with data
2. The new node's next pointer points to the node where head node points to.
3. Head node's next pointer is updated to point to the newly created node.
4. If there is no node in the linked list, tail node's next pointer should set to the new node.
5. Increment count by 1, since a new node has been created.

##### `insert_back` method

`insert_back` method takes `data` as an argument and creates a node with that `data` just like `insert_front` method. However, unlike `insert_front`, `insert_back` method pushes the node at the back of the linked list.

1. Instantiate a new node with data
2. The new node's next pointer points to the tail node.
3. The previous ending node's (the node that the tail node currently points to) next pointer now is set to the new node. The new node is now the ending node.
4. The tail node now points to the new node.
5. Increment count by 1.

##### Adding Some Nodes in the List

Previously we created a linked list named `list`. We can add nodes into this `list` by applying `insert_front` and `insert_back` methods.

##### Code

    list.insert_front(1)
    list.insert_back(2)
    list.insert_front(3)
    list.insert_back(4)

#### Accessing Attributes of the Linked List

Previously we discussed that the linked list class has `head`, `tail` and `count` attributes. You can access these attributes by using accessor methods created with `attr_accessor` method.

##### Code

    list.count
    list.head
    list.tail

Let's print what the accessors return.

##### Code
    puts list.count
    puts list.tail
    puts list.head

    # console output
    4
    #<Node:0x007fef7a083d30>
    #<Node:0x007fef7a083d58>

We have 4 nodes in the linked list, and returns head and tail nodes of the linked list. And finally, you can print the values of first node and the last node.

##### Code

    puts list.head.next.data
    puts list.tail.next.data

    # console output
    3
    4

#### Linked List to Array

Arrays are a type of a list. Linked lists are also a type of a list. It only makes sense that we write a method that converts a listed list into an array.

##### Code

    class SinglyLinkedList
      ...
    
      def to_array
        array = []
        cursor = @head.next
        while cursor != @tail
          array << cursor.data
          cursor = cursor.next
        end
        array
      end
    end

##### `to_array` method

1. Create an array.
2. `cursor` is a pointer. It start from the beginning node.
3. The while loop runs until the `cursor` pointer hits the tail node.
4. Push the data of the current node that `cursor` points to.
5. By the end of the while loop, the array will have all the nodes' data.
6. Return the array.

#### Printing Linked List

We've created a linked list and we can add nodes into it, but we don't have a good way to visualize the result yet. Let us create a method that prints the list.

##### Code

    class SinglyLinkedList
      ...
      
      def print_forward
        puts self.to_array.to_s
      end
      
      def print_reverse
        puts self.to_array.reverse.to_s
      end
    end
    
    ...
    
    list.print_forward
    list.print_reverse   

    # console output
    [3, 1, 2, 4]
    [4, 2, 1, 3]

#### Does This Node Exist in the Linked List?

Say you want to find out if a node exists in the linked list or not. `exist?` is the just the method you are looking for.

##### Code

    class SinglyLinkedList      
      ...
      
      def exist?(data)
        cursor = @head.next
        while cursor != @tail
          if cursor.data == data
            return true
          end
          cursor = cursor.next
        end
        false
      end
    end

    puts list.exist?(4)
    puts list.exist?(5)
    
    # console output
    true
    false

##### `exist?` method

1. `cursor` is a pointer. It start from the beginning node.
2. The while loop runs until the `cursor` pointer hits the tail node.
3. The while loop will end before it reaches the tail node, if the node we are looking for is found. If that is the case, we return true.
4. If the `cursor` pointer reaches the end, the node doesn't exist in the linked list. So we return false.

#### Deleting Node

We should be able to delete nodes in a linked list just as we can add nodes in linked list.

##### Code

    class SinglyLinkedList
      ...
      
      def delete!(data)
        first = @head
        second = @head.next
        while second != @tail
          if second.data == data
            @count -= 1
            first.next = second.next
            return true
          end
          first = first.next
          second = second.next
        end
        false
      end
    end

    puts list.delete!(5)
    puts list.delete!(4)
    list.print_forward

    # console output    
    false
    true
    [3, 1, 2]

##### `delete!` method

1. `data` is taken as an argument for the method
2. We need two pointers. `first` pointer starts at `head` node. `second` pointer starts at the beginning node.
3. The while loop runs until the `second` pointer hits the tail node.
4. As we interate through all the nodes in the linked list, we compare the node data that `second` pointer points to with the `data` argument. If the node data of `second` pointer points to is equal to the `data` argument, then we've found the node to delete.
5. Decrement `count` attribute of the linked list.
6. The node that `first` pointer points to should have `next` set to the node that comes after where the `second` node currently points to.
7. Then return true and terminate the method.
8. If the node is not found in the linked list, return false.

## 4. Stacks
## 5. Queues
## 6. Hash Tables
## 7. Trees
## 8. Heaps
## 9. Sorts
## 10. Searches
## 11. Minimum Spanning Tree
## 12. Dijkstra's Algorithm & Bellman-Ford Algorithm

---